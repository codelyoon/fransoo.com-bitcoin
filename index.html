<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>fransoo.com | Crypto Portal</title>
<style>
  body{background:#000;color:#00bfff;font-family:'Courier New',monospace;margin:0;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;overflow:hidden}
  #static{position:absolute;inset:0;opacity:0.15;pointer-events:none;z-index:1}
  .container{z-index:2;width:100%;max-width:1100px;padding:10px 15px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:10px}
  .typing{font-size:clamp(15px,4vw,21px);text-align:center;margin-bottom:5px;white-space:pre-line}
  .cursor{display:inline-block;width:8px;height:1.1em;background:#00bfff;animation:b 1s infinite}
  @keyframes b{0%,50%{opacity:1}51%,100%{opacity:0}}

  #price-box{display:flex;align-items:center;gap:15px;font-size:clamp(28px,8vw,44px);font-weight:bold;position:relative}
  #coin-display{font-weight:bold;color:#00bfff}
  #coin-select{position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%}
  #price-live{transition:background 0.4s;text-shadow:0 0 15px #00bfff}
  .pulse-green{background:rgba(0,255,0,0.3)!important}
  .pulse-red{background:rgba(255,0,0,0.3)!important}
  .up{color:#0f8}.down{color:#f44}

  #chart-container{position:relative;width:100%;height:58vh;border:1px solid #00bfff;background:#000;border-radius:8px;overflow:hidden;cursor:crosshair}
  canvas{width:100%!important;height:100%!important;display:block}
  #tf-select{position:absolute;top:10px;left:10px;z-index:10;background:#000;border:1px solid #00bfff;color:#00bfff;padding:8px 16px;font-size:15px;border-radius:6px}
  #change{font-size:clamp(16px,4.5vw,22px);font-weight:bold;margin-top:5px}

  #hover-price{
    position:absolute;z-index:20;color:#00bfff;font:bold 15px monospace;
    background:rgba(0,0,0,0.85);padding:8px 14px;border-radius:8px;
    border:1px solid #00bfff;box-shadow:0 0 20px #00bfff;pointer-events:none;
    opacity:0;transition:opacity 0.12s;white-space:nowrap;
    transform:translateX(-50%);left:0;top:0;display:none;
  }
  @media (min-width: 769px) {#hover-price{display:block}}

  @media (max-width: 768px) {
    .container{padding:10px 8px;gap:8px}
    #price-box{gap:10px;font-size:clamp(26px,9vw,38px)}
    #chart-container{height:55vh;cursor:default}
    #tf-select{font-size:14px;padding:7px 14px}
  }
</style>
</head>
<body>
<canvas id="static"></canvas>

<div class="container">
  <div class="typing" id="typing"></div>
  
  <div id="price-box">
    <div id="coin-display">BTC</div>
    <select id="coin-select"></select>
    <span id="price-live">Loading...</span>
  </div>

  <div id="chart-container">
    <select id="tf-select">
      <option value="1">1m</option>
      <option value="5">5m</option>
      <option value="15">15m</option>
      <option value="60">1H</option>
      <option value="240">4H</option>
      <option value="D" selected>1D</option>
      <option value="W">1W</option>
    </select>
    <canvas id="c"></canvas>
    <div id="hover-price"></div>
  </div>
  
  <div id="change">Loading...</div>
</div>

<script>
// Static + typing
const s=document.getElementById('static'),ctx2=s.getContext('2d');
s.width=innerWidth;s.height=innerHeight;
window.addEventListener('resize',()=>{s.width=innerWidth;s.height=innerHeight});
(function n(){const i=ctx2.createImageData(s.width,s.height),d=new Uint32Array(i.data.buffer);
for(let j=0;j<d.length;j++)if(Math.random()<0.09)d[j]=0x33ffffff;ctx2.putImageData(i,0,0);requestAnimationFrame(n)})();

const intro=`welcome to the fransoo.com crypto portal

live charts • top 30 coins • real-time`;
const typing=document.getElementById('typing');
let i=0;
const ti=setInterval(()=>{if(i<intro.length){typing.innerHTML+=intro[i]==='\n'?'<br>':intro[i];i++}
else{clearInterval(ti);typing.innerHTML+='<span class="cursor"></span>'}},45);

const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const priceLive=document.getElementById('price-live');
const changeEl=document.getElementById('change');
const coinDisplay=document.getElementById('coin-display');
const coinSel=document.getElementById('coin-select');
const tfSel=document.getElementById('tf-select');
const hoverPrice=document.getElementById('hover-price');

let currentSymbol = 'BINANCE:BTCUSDT';
let currentName = 'BTC';
let chartData = {prices: [], times: []};
let currentTf = 'D';

// Top 30 coins (TradingView format)
const top30 = [
  {s:'BINANCE:BTCUSDT',n:'BTC'},{s:'BINANCE:ETHUSDT',n:'ETH'},{s:'BINANCE:BNBUSDT',n:'BNB'},
  {s:'BINANCE:SOLUSDT',n:'SOL'},{s:'BINANCE:XRPUSDT',n:'XRP'},{s:'BINANCE:ADAUSDT',n:'ADA'},
  {s:'BINANCE:DOGEUSDT',n:'DOGE'},{s:'BINANCE:TRXUSDT',n:'TRX'},{s:'BINANCE:AVAXUSDT',n:'AVAX'},
  {s:'BINANCE:SHIBUSDT',n:'SHIB'},{s:'BINANCE:LINKUSDT',n:'LINK'},{s:'BINANCE:DOTUSDT',n:'DOT'},
  {s:'BINANCE:LTCUSDT',n:'LTC'},{s:'BINANCE:BCHUSDT',n:'BCH'},{s:'BINANCE:NEARUSDT',n:'NEAR'},
  {s:'BINANCE:MATICUSDT',n:'MATIC'},{s:'BINANCE:UNIUSDT',n:'UNI'},{s:'BINANCE:ICPUSDT',n:'ICP'},
  {s:'BINANCE:APTUSDT',n:'APT'},{s:'BINANCE:XLMUSDT',n:'XLM'},{s:'BINANCE:VETUSDT',n:'VET'},
  {s:'BINANCE:FILUSDT',n:'FIL'},{s:'BINANCE:ATOMUSDT',n:'ATOM'},{s:'BINANCE:ARBUSD',n:'ARB'},
  {s:'BINANCE:SUIUSDT',n:'SUI'}
];

function resize(){
  canvas.width=canvas.offsetWidth*devicePixelRatio;
  canvas.height=canvas.offsetHeight*devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize',resize);resize();

// TradingView Public Data (works everywhere!)
async function getTVData(symbol, resolution, from, to) {
  const url = `https://symbol-search.tradingview.com/symbols/v2/history?symbol=${symbol}&resolution=${resolution}&from=${from}&to=${to}`;
  const res = await fetch(url);
  if (!res.ok) return null;
  return await res.json();
}

async function updateLive(){
  const to = Math.floor(Date.now()/1000);
  const from = to - 86400;
  const data = await getTVData(currentSymbol, '1', from, to);
  if(!data || !data.c || data.c.length === 0) return;

  const price = data.c[data.c.length - 1];
  const prev = data.c[data.c.length - 2] || price;
  const ch24 = ((price - data.c[0]) / data.c[0]) * 100;

  priceLive.innerHTML = `$${price.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2})} <span class="${ch24>=0?'up':'down'}">${ch24>=0?'+' : '-'} ${Math.abs(ch24).toFixed(2)}%</span>`;

  // Update live chart
  chartData.prices.push(price);
  chartData.times.push(new Date(data.t[data.t.length - 1] * 1000));
  if(chartData.prices.length > 400) {chartData.prices.shift(); chartData.times.shift();}
  drawChart(chartData.prices, chartData.times, currentTf);
}

async function loadChart(tf){
  currentTf = tf;
  const to = Math.floor(Date.now()/1000);
  let from, resolution;

  if(tf === '1') {resolution = '1'; from = to - 3600;}
  else if(tf === '5') {resolution = '5'; from = to - 86400;}
  else if(tf === '15') {resolution = '15'; from = to - 86400*2;}
  else if(tf === '60') {resolution = '60'; from = to - 86400*7;}
  else if(tf === '240') {resolution = '240'; from = to - 86400*30;}
  else if(tf === 'D') {resolution = 'D'; from = to - 86400*180;}
  else if(tf === 'W') {resolution = 'W'; from = to - 86400*730;}
  else {resolution = 'D'; from = to - 86400*365;}

  const data = await getTVData(currentSymbol, resolution, from, to);
  if(!data || !data.c) return;

  chartData.prices = data.c;
  chartData.times = data.t.map(t => new Date(t * 1000));

  const first = data.c[0], last = data.c[data.c.length-1];
  const change = ((last-first)/first)*100;
  changeEl.innerHTML = `<span class="${change>=0?'up':'down'}">${change>=0?'+' : '-'} ${Math.abs(change).toFixed(2)}%</span> (${tfSel.options[tfSel.selectedIndex].text})`;

  drawChart(chartData.prices, chartData.times, tf);
}

// drawChart() + hover (same as before, just simplified)
function drawChart(prices, times, tf){
  resize();
  const W=canvas.width/devicePixelRatio, H=canvas.height/devicePixelRatio;
  ctx.clearRect(0,0,W,H);
  if(prices.length < 2) return;

  const padX=65, padY=45, chartWidth=W-padX-85, chartHeight=H-90;
  const max=Math.max(...prices), min=Math.min(...prices), range=max-min||1;

  ctx.fillStyle='rgba(0,191,255,0.12)';
  ctx.beginPath();
  prices.forEach((p,i)=>{const x=padX+i*(chartWidth/(prices.length-1));
    const y=H-padY-((p-min)/range)*chartHeight;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});
  ctx.lineTo(W-85,H-padY);ctx.lineTo(padX,H-padY);ctx.closePath();ctx.fill();

  ctx.strokeStyle='#00bfff';ctx.lineWidth=2.5;ctx.beginPath();
  prices.forEach((p,i)=>{const x=padX+i*(chartWidth/(prices.length-1));
    const y=H-padY-((p-min)/range)*chartHeight;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});
  ctx.stroke();

  const lastX = padX + (prices.length-1)*(chartWidth/(prices.length-1));
  const lastY = H-padY-((prices[prices.length-1]-min)/range)*chartHeight;
  ctx.fillStyle = '#00bfff';
  ctx.beginPath(); ctx.arc(lastX, lastY, 8, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 2.5; ctx.stroke();

  // Grid + Axis
  ctx.strokeStyle='#003340';
  for(let i=0;i<=5;i++){
    const y=padY+i*(chartHeight/5);
    ctx.beginPath();ctx.moveTo(padX,y);ctx.lineTo(W-85,y);ctx.stroke();
  }
  ctx.fillStyle='#00bfff';ctx.font='14px monospace';ctx.textAlign='right';
  for(let i=0;i<=5;i++){
    const val=max-i*(range/5);
    const y=padY+i*(chartHeight/5);
    ctx.fillText('$' + val.toFixed(val>1000?0:2).replace(/\B(?=(\d{3})+(?!\d))/g, ','), W-15, y+5);
  }

  ctx.strokeStyle='#00bfff';ctx.lineWidth=1.8;
  ctx.strokeRect(padX,padY,chartWidth,chartHeight);
}

// Hover (same pixel-perfect logic)
canvas.addEventListener('mousemove', e => {
  if(innerWidth <= 768) return;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const W = canvas.width/devicePixelRatio;
  const H = canvas.height/devicePixelRatio;
  const padX=65, chartWidth=W-padX-85, chartHeight=H-90;

  if(mouseX < padX || mouseX > W-85) {hoverPrice.style.opacity='0'; drawChart(chartData.prices, chartData.times, currentTf); return;}

  const prices = chartData.prices;
  if(prices.length < 2) return;
  const max=Math.max(...prices), min=Math.min(...prices), range=max-min||1;
  const fraction = (mouseX - padX) / chartWidth;
  const index = Math.round(fraction * (prices.length - 1));
  if(index < 0 || index >= prices.length) return;

  const price = prices[index];
  const pointX = padX + index * (chartWidth / (prices.length - 1));
  const pointY = H - 45 - ((price - min) / range) * chartHeight;

  drawChart(prices, chartData.times, currentTf);
  ctx.fillStyle = '#00ffff';
  ctx.beginPath(); ctx.arc(pointX, pointY, 7, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 3; ctx.stroke();

  hoverPrice.textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
  hoverPrice.style.left = pointX + 'px';
  hoverPrice.style.top = (pointY - 34) + 'px';
  hoverPrice.style.opacity = '1';
});
canvas.addEventListener('mouseout', () => {
  hoverPrice.style.opacity = '0';
  drawChart(chartData.prices, chartData.times, currentTf);
});

// Init
coinSel.onchange = () => {
  currentSymbol = coinSel.value;
  currentName = coinSel.selectedOptions[0].text.split(' ')[0];
  coinDisplay.textContent = currentName;
  chartData = {prices: [], times: []};
  loadChart(tfSel.value);
};
tfSel.onchange = () => loadChart(tfSel.value);

async function init(){
  top30.forEach(coin => {
    const opt = document.createElement('option');
    opt.value = coin.s;
    opt.textContent = `${coin.n} Loading...`;
    if(coin.s === currentSymbol) opt.selected = true;
    coinSel.appendChild(opt);
  });
  loadChart('D');
}
init();

setInterval(updateLive, 5000);
</script>
</body>
</html>
