<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>fransoo.com | Crypto Portal</title>
<style>
  body{background:#000;color:#00bfff;font-family:'Courier New',monospace;margin:0;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;overflow:hidden}
  #static{position:absolute;inset:0;opacity:0.85;pointer-events:none;z-index:1}
  .container{z-index:2;width:100%;max-width:1100px;padding:10px 15px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:10px}
  .typing{font-size:clamp(15px,4vw,21px);text-align:center;margin-bottom:5px;white-space:pre-line}
  .cursor{display:inline-block;width:8px;height:1.1em;background:#00bfff;animation:b 1s infinite}
  @keyframes b{0%,50%{opacity:1}51%,100%{opacity:0}}

  #price-box{display:flex;align-items:center;gap:15px;font-size:clamp(28px,8vw,44px);font-weight:bold;position:relative}
  #coin-display{font-weight:bold;color:#00bfff}
  #coin-select{position:absolute;inset:0;opacity:0;cursor:pointer}
  #price-live{transition:background 0.4s;text-shadow:0 0 15px #00bfff}
  .pulse-green{background:rgba(0,255,0,0.3)!important}
  .pulse-red{background:rgba(255,0,0,0.3)!important}
  .up{color:#0f8}.down{color:#f44}

  #chart-container{position:relative;width:100%;height:58vh;border:1px solid #00bfff;background:#000;border-radius:8px;overflow:hidden;cursor:crosshair}
  canvas{width:100%!important;height:100%!important;display:block}
  #tf-select{position:absolute;top:10px;left:10px;z-index:10;background:#000;border:1px solid #00bfff;color:#00bfff;padding:8px 16px;font-size:15px;border-radius:6px;outline:none}
  #change{font-size:clamp(16px,4.5vw,22px);font-weight:bold;margin-top:5px}

  /* Hover price label (desktop only) */
  #hover-price{
    position:absolute;z-index:20;color:#00bfff;font:bold 15px monospace;
    background:rgba(0,0,0,0.7);padding:6px 10px;border-radius:6px;
    border:1px solid #00bfff;box-shadow:0 0 15px #00bfff;pointer-events:none;
    opacity:0;transition:opacity 0.2s;display:none;
  }
  @media (min-width: 769px) {#hover-price{display:block}}

  /* Mobile tweaks */
  @media (max-width: 768px) {
    .container{padding:10px 8px;gap:8px}
    #price-box{gap:10px;font-size:clamp(26px,9vw,38px)}
    #chart-container{height:55vh;cursor:default}
    #tf-select{font-size:14px;padding:7px 14px}
    #change{font-size:18px}
  }
</style>
</head>
<body>
<canvas id="static"></canvas>

<div class="container">
  <div class="typing" id="typing"></div>
  
  <div id="price-box">
    <div id="coin-display">BTC</div>
    <select id="coin-select"></select>
    <span id="price-live">Loading...</span>
  </div>

  <div id="chart-container">
    <select id="tf-select">
      <option value="live">LIVE</option>
      <option value="1h">1H</option>
      <option value="1d">1D</option>
      <option value="7d" selected>7D</option>
      <option value="30d">30D</option>
      <option value="ytd">YTD</option>
      <option value="all">ALL</option>
    </select>
    <canvas id="c"></canvas>
    <div id="hover-price"></div>
  </div>
  
  <div id="change">Loading...</div>
</div>

<script>
// Static + typing
const s=document.getElementById('static'),ctx2=s.getContext('2d');
s.width=innerWidth;s.height=innerHeight;
window.addEventListener('resize',()=>{s.width=innerWidth;s.height=innerHeight});
(function n(){const i=ctx2.createImageData(s.width,s.height),d=new Uint32Array(i.data.buffer);
for(let j=0;j<d.length;j++)if(Math.random()<0.09)d[j]=0x33ffffff;ctx2.putImageData(i,0,0);requestAnimationFrame(n)})();

const intro=`welcome to the fransoo.com crypto portal

live charts • top 30 coins • real-time`;
const typing=document.getElementById('typing');
let i=0;
const ti=setInterval(()=>{if(i<intro.length){typing.innerHTML+=intro[i]==='\n'?'<br>':intro[i];i++}
else{clearInterval(ti);typing.innerHTML+='<span class="cursor"></span>'}},45);

const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const priceLive=document.getElementById('price-live');
const changeEl=document.getElementById('change');
const coinDisplay=document.getElementById('coin-display');
const coinSel=document.getElementById('coin-select');
const tfSel=document.getElementById('tf-select');
const hoverPrice = document.getElementById('hover-price');

let currentSymbol = 'BTCUSDT';
let currentName = 'BTC';
let lastPrice = 0;
let chartData = {prices: [], times: []};
let lastCandleTime = 0;
let currentTf = '7d';

const top30 = [
  {s:'BTCUSDT',n:'BTC'},{s:'ETHUSDT',n:'ETH'},{s:'BNBUSDT',n:'BNB'},{s:'SOLUSDT',n:'SOL'},
  {s:'XRPUSDT',n:'XRP'},{s:'ADAUSDT',n:'ADA'},{s:'DOGEUSDT',n:'DOGE'},{s:'TRXUSDT',n:'TRX'},
  {s:'AVAXUSDT',n:'AVAX'},{s:'SHIBUSDT',n:'SHIB'},{s:'LINKUSDT',n:'LINK'},{s:'DOTUSDT',n:'DOT'},
  {s:'LTCUSDT',n:'LTC'},{s:'BCHUSDT',n:'BCH'},{s:'NEARUSDT',n:'NEAR'},{s:'HBARUSDT',n:'HBAR'},
  {s:'MATICUSDT',n:'MATIC'},{s:'UNIUSDT',n:'UNI'},{s:'ICPUSDT',n:'ICP'},{s:'APTUSDT',n:'APT'},
  {s:'CROUSDT',n:'CRO'},{s:'XLMUSDT',n:'XLM'},{s:'VETUSDT',n:'VET'},{s:'FILUSDT',n:'FIL'},
  {s:'KASUSDT',n:'KAS'},{s:'ATOMUSDT',n:'ATOM'},{s:'STXUSDT',n:'STX'},{s:'ARBUSDT',n:'ARB'},
  {s:'IMXUSDT',n:'IMX'},{s:'SUIUSDT',n:'SUI'}
];

function resize(){
  canvas.width=canvas.offsetWidth*devicePixelRatio;
  canvas.height=canvas.offsetHeight*devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize',resize);resize();

async function safeFetch(url){
  try{
    const r = await fetch(url,{cache:"no-store"});
    if(!r.ok) return null;
    return await r.json();
  }catch{return null}
}

async function updateDropdown(){
  for(let i=0;i<top30.length;i++){
    const coin = top30[i];
    const data = await safeFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${coin.s}`);
    if(data){
      const change = +data.priceChangePercent;
      coinSel.options[i].textContent = `${coin.n} ${change>=0?'Up':'Down'} ${Math.abs(change).toFixed(2)}%`;
    }
  }
}

async function updateLive(){
  const data = await safeFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${currentSymbol}`);
  if(!data) return;

  const price = +data.lastPrice;
  const ch24 = +data.priceChangePercent;
  const now = Date.now();

  if(lastPrice !== 0 && price !== lastPrice){
    priceLive.classList.add(price > lastPrice ? 'pulse-green' : 'pulse-red');
    setTimeout(()=>priceLive.classList.remove('pulse-green','pulse-red'),500);
  }
  lastPrice = price;

  priceLive.innerHTML = `$${price.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2})} <span class="${ch24>=0?'up':'down'}">${ch24>=0?'+' : '-'} ${Math.abs(ch24).toFixed(2)}%</span>`;

  if(currentTf === 'live'){
    chartData.prices.push(price);
    chartData.times.push(new Date(now));
    if(chartData.prices.length > 400) { chartData.prices.shift(); chartData.times.shift(); }
  } else {
    const intervalMs = {'1h':60*1000,'1d':86400000,'7d':3600000,'30d':86400000*30,'ytd':86400000*365,'all':604800000}[currentTf] || 3600000;
    const candleTime = Math.floor(now / intervalMs) * intervalMs;
    if(candleTime !== lastCandleTime){
      lastCandleTime = candleTime;
      chartData.prices.push(price);
      chartData.times.push(new Date(candleTime));
    } else if(chartData.prices.length > 0){
      chartData.prices[chartData.prices.length-1] = price;
    }
  }
  drawChart(chartData.prices, chartData.times, currentTf, price > lastPrice ? '#0f8' : price < lastPrice ? '#f44' : '#00bfff');
}

async function loadChart(tf){
  currentTf = tf;
  if(tf==='live') { chartData = {prices: [], times: []}; drawChart([], [], 'live'); return; }

  let interval='1h', limit=168;
  if(tf==='1h'){interval='1m';limit=60}
  else if(tf==='1d'){interval='5m';limit=288}
  else if(tf==='7d'){interval='1h';limit=168}
  else if(tf==='30d'){interval='4h';limit=180}
  else if(tf==='ytd'){interval='1d';limit=365}
  else{interval='1w';limit=1000}

  const data = await safeFetch(`https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${interval}&limit=${limit}`);
  if(!data || data.length<2) return;

  chartData.prices = data.map(k=>+k[4]);
  chartData.times = data.map(k=>new Date(k[0]));

  const first=chartData.prices[0], last=chartData.prices[chartData.prices.length-1];
  const change = ((last-first)/first)*100;
  const tfName = tfSel.options[tfSel.selectedIndex].text;
  changeEl.innerHTML = `<span class="${change>=0?'up':'down'}">${change>=0?'+' : '-'} ${Math.abs(change).toFixed(2)}%</span> (${tfName})`;

  drawChart(chartData.prices, chartData.times, tf);
}

function drawChart(prices, times, tf, dotColor = '#00bfff'){
  resize();
  const W=canvas.width/devicePixelRatio, H=canvas.height/devicePixelRatio;
  ctx.clearRect(0,0,W,H);
  if(prices.length < 2) return;

  const padX=65, padY=45, chartWidth=W-padX-85, chartHeight=H-2*padY;
  const max=Math.max(...prices), min=Math.min(...prices), range=max-min||1;

  // Area + Line
  ctx.fillStyle='rgba(0,191,255,0.12)';
  ctx.beginPath();
  prices.forEach((p,i)=>{const x=padX+i*(chartWidth/(prices.length-1));
    const y=H-padY-((p-min)/range)*chartHeight;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});
  ctx.lineTo(W-85,H-padY);ctx.lineTo(padX,H-padY);ctx.closePath();ctx.fill();

  ctx.strokeStyle='#00bfff';ctx.lineWidth=2.5;ctx.beginPath();
  prices.forEach((p,i)=>{const x=padX+i*(chartWidth/(prices.length-1));
    const y=H-padY-((p-min)/range)*chartHeight;
    i===0?ctx.moveTo(x,y):ctx.lineTo(x,y)});
  ctx.stroke();

  // Live end dot
  const lastX = padX + (prices.length-1)*(chartWidth/(prices.length-1));
  const lastY = H-padY-((prices[prices.length-1]-min)/range)*chartHeight;
  ctx.fillStyle = dotColor;
  ctx.beginPath(); ctx.arc(lastX, lastY, 8, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 2.5; ctx.stroke();

  // Grid + Price Axis + Time Labels (same as before)
  ctx.strokeStyle='#003340';
  for(let i=0;i<=5;i++){
    const y = padY + i*(chartHeight/5);
    ctx.beginPath(); ctx.moveTo(padX,y); ctx.lineTo(W-85,y); ctx.stroke();
  }
  ctx.fillStyle='#00bfff'; ctx.font='14px monospace'; ctx.textAlign='right';
  for(let i=0;i<=5;i++){
    const val = max - i*(range/5);
    const y = padY + i*(chartHeight/5);
    ctx.fillText('$' + val.toFixed(val > 1000 ? 0 : 2).replace(/\B(?=(\d{3})+(?!\d))/g, ','), W-15, y + 5);
  }

  if(tf !== 'live'){
    ctx.textAlign='center'; ctx.font='13px monospace';
    const count = innerWidth<=768?4:7;
    for(let i=0;i<=count;i++){
      const idx=Math.round(i*(prices.length-1)/count);
      const x=padX+idx*(chartWidth/(prices.length-1));
      const d=times[idx];
      let label = tf==='1h' ? d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}).replace(/:\d\d$/,'') :
                  tf==='1d' ? d.getHours()+'h' :
                  tf==='7d'||tf==='30d' ? d.toLocaleDateString('en-US',{month:'short',day:'numeric'}) :
                  tf==='ytd' ? d.toLocaleDateString('en-US',{month:'short'}) : d.getFullYear();
      ctx.fillText(label,x,H-padY+25);
    }
  }

  ctx.strokeStyle='#00bfff';ctx.lineWidth=1.8;
  ctx.strokeRect(padX,padY,chartWidth,chartHeight);
}

// HOVER PRICE TRACKING (DESKTOP ONLY)
let hoverIndex = -1;
canvas.addEventListener('mousemove', e => {
  if(innerWidth <= 768) return; // disable on mobile
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const W = canvas.width/devicePixelRatio;
  const H = canvas.height/devicePixelRatio;
  const padX=65, chartWidth=W-padX-85, chartHeight=H-90;

  if(x < padX || x > W-85 || y < 45 || y > H-45) {
    hoverPrice.style.opacity = '0';
    hoverIndex = -1;
    return;
  }

  const prices = chartData.prices;
  if(prices.length < 2) return;

  const max=Math.max(...prices), min=Math.min(...prices), range=max-min||1;
  const pointX = padX + (x - padX) * (prices.length-1) / chartWidth;
  hoverIndex = Math.round(pointX);
  if(hoverIndex < 0 || hoverIndex >= prices.length) return;

  const price = prices[hoverIndex];
  const priceY = H-45 - ((price-min)/range)*chartHeight;

  // Draw hover dot
  ctx.clearRect(0,0,W,H);
  drawChart(prices, chartData.times, currentTf); // redraw base
  ctx.fillStyle = '#00ffff';
  ctx.beginPath(); ctx.arc(padX + hoverIndex*(chartWidth/(prices.length-1)), priceY, 6, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 2; ctx.stroke();

  // Show floating price
  hoverPrice.textContent = `$${price.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2})}`;
  hoverPrice.style.left = (e.clientX - rect.left + 10) + 'px';
  hoverPrice.style.top = (e.clientY - rect.top - 30) + 'px';
  hoverPrice.style.opacity = '1';
});

canvas.addEventListener('mouseout', () => {
  hoverPrice.style.opacity = '0';
  hoverIndex = -1;
  drawChart(chartData.prices, chartData.times, currentTf);
});

// Events + Init
coinSel.onchange = () => {
  const opt = coinSel.options[coinSel.selectedIndex];
  currentSymbol = coinSel.value;
  currentName = opt.textContent.split(' ')[0];
  coinDisplay.textContent = currentName;
  lastPrice = 0; chartData = {prices: [], times: []}; lastCandleTime = 0;
  loadChart(tfSel.value);
};
tfSel.onchange = () => loadChart(tfSel.value);

async function init(){
  coinSel.innerHTML = '';
  top30.forEach(coin => {
    const opt = document.createElement('option');
    opt.value = coin.s;
    opt.textContent = `${coin.n} Loading...`;
    if(coin.s===currentSymbol) opt.selected = true;
    coinSel.appendChild(opt);
  });
  updateDropdown();
  loadChart('7d');
}
init();

setInterval(updateLive, 3000);
setInterval(updateDropdown, 60000);
</script>
</body>
</html>
