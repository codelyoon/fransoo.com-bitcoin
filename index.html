<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fransoo.com | BTC Live</title>
  <style>
    body {background:#000;color:#00bfff;font-family:'Courier New',monospace;margin:0;overflow:hidden;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}
    #static-canvas {position:absolute;top:0;left:0;width:100%;height:100%;opacity:0.15;pointer-events:none;z-index:1}
    .container {z-index:2;text-align:center;max-width:900px;width:100%;padding:20px;box-sizing:border-box}
    .typing {font-size:20px;white-space:pre-line}
    .cursor {display:inline-block;width:10px;height:22px;background:#00bfff;animation:blink 1s infinite;vertical-align:middle}
    @keyframes blink {0%,50%{opacity:1}51%,100%{opacity:0}}
    #price-box {position:absolute;top:20px;right:20px;font-size:28px;font-weight:bold;letter-spacing:1px;z-index:3}
    .up {color:#00ff00}
    .down {color:#ff0044}
    #chart-container {margin-top:50px;width:100%;height:50vh;background:#000;border:1px solid #00bfff;box-sizing:border-box}
    canvas#chart {width:100%;height:100%;display:block}
    #loading {color:#666;font-size:14px;margin-top:10px}
  </style>
</head>
<body>
  <canvas id="static-canvas"></canvas>
  <div id="price-box">BTC $--.---</div>
  <div class="container">
    <div class="typing" id="typing"></div>
    <div id="chart-container"><canvas id="chart"></canvas><div id="loading">Loading chart...</div></div>
  </div>

  <script>
    // Static noise
    const sc = document.getElementById('static-canvas');
    const sctx = sc.getContext('2d');
    sc.width = innerWidth; sc.height = innerHeight;
    window.addEventListener('resize',()=>{sc.width=innerWidth;sc.height=innerHeight});
    (function noise(){const d=sctx.createImageData(sc.width,sc.height);const b=new Uint32Array(d.data.buffer);
      for(let i=0;i<b.length;i++)if(Math.random()<0.09)b[i]=0x33ffffff;sctx.putImageData(d,0,0);requestAnimationFrame(noise);})();

    const intro = `welcome to the fransoo.com finance portal

here's the live BTC chart & price`;
    
    const typingEl = document.getElementById('typing');
    const priceBox = document.getElementById('price-box');
    const chartCanvas = document.getElementById('chart');
    const loadingEl = document.getElementById('loading');
    const ctx = chartCanvas.getContext('2d');

    function type(text, el, cb) {
      let i=0;
      const int = setInterval(()=>{
        if(i<text.length){el.innerHTML += text[i]==='\n'?'<br>':text[i];i++}
        else{clearInterval(int);if(cb)cb()}
      },45);
    }

    type(intro, typingEl, ()=>typingEl.innerHTML += '<span class="cursor"></span>');

    // Resize chart canvas properly
    function resizeChart() {
      const rect = chartCanvas.getBoundingClientRect();
      chartCanvas.width = rect.width * window.devicePixelRatio;
      chartCanvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('resize', resizeChart);
    resizeChart();

    let prices = [];
    let currentPrice = 0;
    let change24h = 0;

    async function fetchBTC() {
      try {
        loadingEl.textContent = 'Fetching BTC data...';
        // Binance ticker for current price + 24h change
        const res1 = await fetch('https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT');
        if (!res1.ok) throw new Error('Binance fetch fail');
        const data = await res1.json();
        currentPrice = parseFloat(data.lastPrice);
        const changePercent = parseFloat(data.priceChangePercent);
        change24h = changePercent;

        priceBox.innerHTML = `BTC $${currentPrice.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})} 
          <span class="${change24h>=0?'up':'down'}">${change24h>=0?'↑':'↓'}${Math.abs(change24h).toFixed(2)}%</span>`;

        // 24h hourly klines for chart (last 24 hours, 1h intervals = 25 points)
        const res2 = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=25');
        if (!res2.ok) throw new Error('Binance klines fail');
        const klines = await res2.json();
        prices = klines.map(k => parseFloat(k[4])); // Close prices

        loadingEl.style.display = 'none';
        drawChart();
      } catch(e) {
        console.error(e);
        priceBox.innerHTML = `BTC -- <span class="down">Fetch jammed – HODL anyway</span>`;
        loadingEl.textContent = 'API hiccup – refresh page';
      }
    }

    function drawChart() {
      resizeChart();
      const cw = chartCanvas.width / window.devicePixelRatio; // logical width
      const ch = chartCanvas.height / window.devicePixelRatio; // logical height
      ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);

      const pad = 50;
      const maxP = Math.max(...prices);
      const minP = Math.min(...prices);
      const range = maxP - minP || 1;
      const numPoints = prices.length;

      let step = 0;
      function anim() {
        ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);

        // Grid lines (horizontal)
        ctx.strokeStyle = '#003340';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const gy = pad + (ch - 2 * pad) * i / 4;
          ctx.beginPath();
          ctx.moveTo(pad, gy);
          ctx.lineTo(cw - pad, gy);
          ctx.stroke();
        }

        // Animate line path
        const pointsToDraw = Math.min(Math.floor(step / 3), numPoints - 1);
        if (pointsToDraw >= 0) {
          const path = [];
          for (let i = 0; i <= pointsToDraw; i++) {
            const x = pad + (cw - 2 * pad) * (i / (numPoints - 1));
            const y = ch - pad - ((prices[i] - minP) / range) * (ch - 2 * pad);
            path.push({x, y});
          }

          // Draw line
          ctx.strokeStyle = '#00bfff';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.stroke();

          // Subtle fill under line
          ctx.fillStyle = 'rgba(0, 191, 255, 0.1)';
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.lineTo(path[path.length - 1].x, ch - pad);
          ctx.lineTo(path[0].x, ch - pad);
          ctx.closePath();
          ctx.fill();
        }

        // Y-axis labels (fixed positioning: top=max, bottom=min)
        ctx.fillStyle = '#00bfff';
        ctx.font = '14px monospace';
        ctx.textAlign = 'right';
        const yTicks = [maxP, (maxP + minP) / 2, minP];
        yTicks.forEach((tick, idx) => {
          const ty = ch - pad - (idx * (ch - 2 * pad) / 2);
          ctx.fillText(`$${Math.round(tick).toLocaleString()}`, cw - pad - 10, ty + 4);
        });

        // X-axis labels (hours ago, reversed for recency)
        ctx.textAlign = 'center';
        for (let i = 0; i < 5; i++) {
          const hourIdx = Math.floor((numPoints - 1) * i / 4);
          const x = pad + (cw - 2 * pad) * (hourIdx / (numPoints - 1));
          ctx.fillText(`${24 - Math.floor(hourIdx)}h`, x, ch - pad + 18);
        }

        if (step < numPoints * 3) {
          step++;
          requestAnimationFrame(anim);
        }
      }
      anim();
    }

    // Kick it off
    fetchBTC();
    setInterval(fetchBTC, 30000); // Refresh every 30s
  </script>
</body>
</html>
